{"version":3,"file":"translate.parser.js","sources":["@ngx-translate/core/projects/ngx-translate/core/src/lib/translate.parser.ts"],"names":[],"mappings":"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","sourcesContent":["import {Injectable} from \"@angular/core\";\nimport {isDefined} from \"./util\";\n\nexport abstract class TranslateParser {\n  /**\n   * Interpolates a string to replace parameters\n   * \"This is a {{ key }}\" ==> \"This is a value\", with params = { key: \"value\" }\n   * @param expr\n   * @param params\n   */\n  abstract interpolate(expr: string | Function, params?: any): string;\n\n  /**\n   * Gets a value from an object by composed key\n   * parser.getValue({ key1: { keyA: 'valueI' }}, 'key1.keyA') ==> 'valueI'\n   * @param target\n   * @param key\n   */\n  abstract getValue(target: any, key: string): any\n}\n\n@Injectable()\nexport class TranslateDefaultParser extends TranslateParser {\n  templateMatcher: RegExp = /{{\\s?([^{}\\s]*)\\s?}}/g;\n\n  public interpolate(expr: string | Function, params?: any): string {\n    let result: string;\n\n    if (typeof expr === 'string') {\n      result = this.interpolateString(expr, params);\n    } else if (typeof expr === 'function') {\n      result = this.interpolateFunction(expr, params);\n    } else {\n      // this should not happen, but an unrelated TranslateService test depends on it\n      result = expr as string;\n    }\n\n    return result;\n  }\n\n  getValue(target: any, key: string): any {\n    let keys = key.split('.');\n    key = '';\n    do {\n      key += keys.shift();\n      if (isDefined(target) && isDefined(target[key]) && (typeof target[key] === 'object' || !keys.length)) {\n        target = target[key];\n        key = '';\n      } else if (!keys.length) {\n        target = undefined;\n      } else {\n        key += '.';\n      }\n    } while (keys.length);\n\n    return target;\n  }\n\n  private interpolateFunction(fn: Function, params?: any) {\n    return fn(params);\n  }\n\n  private interpolateString(expr: string, params?: any) {\n    if (!params) {\n      return expr;\n    }\n\n    return expr.replace(this.templateMatcher, (substring: string, b: string) => {\n      let r = this.getValue(params, b);\n      return isDefined(r) ? r : substring;\n    });\n  }\n}\n"]}