{"version":3,"file":"ngx-auth.js.map","sources":["ng://ngx-auth/auth.service.ts","ng://ngx-auth/tokens.ts","ng://ngx-auth/public.guard.ts","ng://ngx-auth/protected.guard.ts","ng://ngx-auth/auth.interceptor.ts","ng://ngx-auth/auth.module.ts"],"sourcesContent":["import { HttpRequest, HttpErrorResponse } from '@angular/common/http';\nimport { Observable } from 'rxjs';\n\n/**\n * Essential service for authentication\n */\nexport abstract class AuthService {\n\n  /**\n   * Check, if user already authorized.\n   * Should return Observable with true or false values\n   */\n  public abstract isAuthorized(): Observable<boolean>;\n\n  /**\n   * Get access token\n   * Should return access token in Observable from e.g.\n   * localStorage\n   */\n  public abstract getAccessToken(): Observable<string>;\n\n  /**\n   * Function, that should perform refresh token\n   * Should be successfully completed so interceptor\n   * can execute pending requests or retry original one\n   */\n  public abstract refreshToken(): Observable<any>;\n\n  /**\n   * Function, checks response of failed request to determine,\n   * whether token be refreshed or not.\n   *\n   * Essentially checks status\n   */\n  public abstract refreshShouldHappen(response: HttpErrorResponse, request?: HttpRequest<any>): boolean;\n\n  /**\n   * Verify that outgoing request is refresh-token,\n   * so interceptor won't intercept this request\n   */\n  public abstract verifyRefreshToken?(request: HttpRequest<any>): boolean;\n\n  /**\n   * Checks if request must be skipped by interceptor.\n   * Useful for requests such as request token which doesn't require token in headers\n   */\n  public abstract skipRequest?(request: HttpRequest<any>): boolean;\n\n  /**\n   * Add token to headers, dependent on server\n   * set-up, by default adds a bearer token.\n   * Called by interceptor.\n   * To change behavior, override this method.\n   */\n  public abstract getHeaders?(token: string): { [name: string]: string | string[] };\n\n  /**\n   * Saves last interrupted url inside of the service for further reusage,\n   * e.g. restoring interrupted page after logging in\n   */\n  public abstract setInterruptedUrl?(url: string): void;\n\n  /**\n   * Verify that outgoing request is refresh-token,\n   * so interceptor won't intercept this request\n   * @deprecated Due to illogical meaning/functionality this method is deprecated\n   * @see verifyRefreshToken\n   */\n  public abstract verifyTokenRequest?(url: string): boolean;\n}\n","import { InjectionToken } from '@angular/core';\n\nexport const AUTH_SERVICE = new InjectionToken('AUTH_SERVICE');\nexport const PUBLIC_FALLBACK_PAGE_URI = new InjectionToken('PUBLIC_FALLBACK_PAGE_URI');\nexport const PROTECTED_FALLBACK_PAGE_URI = new InjectionToken('PROTECTED_FALLBACK_PAGE_URI');\n","import { DOCUMENT } from '@angular/common';\nimport { Injectable, Inject } from '@angular/core';\nimport {\n  CanActivate,\n  CanActivateChild,\n  Router,\n  ActivatedRouteSnapshot,\n  RouterStateSnapshot\n} from '@angular/router';\nimport { Observable } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nimport { AuthService } from './auth.service';\nimport { AUTH_SERVICE, PROTECTED_FALLBACK_PAGE_URI } from './tokens';\n\n/**\n * Guard, checks access token availability and allows or disallows access to page,\n * and redirects out\n *\n * usage: { path: 'test', component: TestComponent, canActivate: [ PublicGuard ] }\n *\n * @export\n * @dynamic\n */\n@Injectable()\nexport class PublicGuard implements CanActivate, CanActivateChild {\n\n  constructor(\n    @Inject(AUTH_SERVICE) private authService: AuthService,\n    @Inject(PROTECTED_FALLBACK_PAGE_URI) private protectedFallbackPageUri: string,\n    @Inject(DOCUMENT) private readonly document: Document,\n    private router: Router\n  ) {}\n\n  /**\n   * CanActivate handler\n   */\n  public canActivate(\n    _route: ActivatedRouteSnapshot,\n    state: RouterStateSnapshot\n  ): Observable<boolean> {\n    return this.authService.isAuthorized()\n      .pipe(map((isAuthorized: boolean) => {\n        if (isAuthorized && !this.isProtectedPage(state)) {\n          this.navigate(this.protectedFallbackPageUri);\n\n          return false;\n        }\n\n        return true;\n      }));\n  }\n\n  /**\n   * CanActivateChild handler\n   */\n  public canActivateChild(\n    route: ActivatedRouteSnapshot,\n    state: RouterStateSnapshot\n  ): Observable<boolean> {\n    return this.canActivate(route, state);\n  }\n\n  /**\n   * Check, if current page is protected fallback page\n   */\n  private isProtectedPage(state: RouterStateSnapshot): boolean {\n    return state.url === this.protectedFallbackPageUri;\n  }\n\n  /**\n   * Navigate away from the app / path\n   */\n  private navigate(url: string): void {\n    if (url.startsWith('http')) {\n      this.document.location.href = url;\n    } else {\n      this.router.navigateByUrl(url);\n    }\n  }\n\n}\n","import { DOCUMENT } from '@angular/common';\nimport { Injectable, Inject } from '@angular/core';\nimport {\n  Router,\n  CanActivate,\n  CanActivateChild,\n  ActivatedRouteSnapshot,\n  RouterStateSnapshot\n} from '@angular/router';\nimport { Observable } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nimport { AuthService } from './auth.service';\nimport { AUTH_SERVICE, PUBLIC_FALLBACK_PAGE_URI } from './tokens';\n\n/**\n * Guard, checks access token availability and allows or disallows access to page,\n * and redirects out\n *\n * usage: { path: 'test', component: TestComponent, canActivate: [ AuthGuard ] }\n *\n * @export\n * @dynamic\n */\n@Injectable()\nexport class ProtectedGuard implements CanActivate, CanActivateChild {\n\n  constructor(\n    @Inject(AUTH_SERVICE)private authService: AuthService,\n    @Inject(PUBLIC_FALLBACK_PAGE_URI) private publicFallbackPageUri: string,\n    @Inject(DOCUMENT) private readonly document: Document,\n    private router: Router\n  ) {}\n\n  /**\n   * CanActivate handler\n   */\n  public canActivate(\n    _route: ActivatedRouteSnapshot,\n    state: RouterStateSnapshot\n  ): Observable<boolean> {\n    return this.authService.isAuthorized()\n      .pipe(map((isAuthorized: boolean) => {\n        if (!isAuthorized && !this.isPublicPage(state)) {\n          if (this.authService.setInterruptedUrl) {\n            this.authService.setInterruptedUrl(state.url);\n          }\n\n          this.navigate(this.publicFallbackPageUri);\n\n          return false;\n        }\n\n        return true;\n      }));\n  }\n\n  /**\n   * CanActivateChild handler\n   */\n  public canActivateChild(\n    route: ActivatedRouteSnapshot,\n    state: RouterStateSnapshot\n  ): Observable<boolean> {\n    return this.canActivate(route, state);\n  }\n\n  /**\n   * Check, if current page is public fallback page\n   */\n  private isPublicPage(state: RouterStateSnapshot): boolean {\n    return state.url === this.publicFallbackPageUri;\n  }\n\n  /**\n   * Navigate away from the app / path\n   */\n  private navigate(url: string): void {\n    if (url.startsWith('http')) {\n      this.document.location.href = url;\n    } else {\n      this.router.navigateByUrl(url);\n    }\n  }\n\n}\n","import { Injectable, Injector } from '@angular/core';\nimport {\n  HttpClient,\n  HttpEvent,\n  HttpInterceptor,\n  HttpHandler,\n  HttpRequest,\n  HttpErrorResponse\n} from '@angular/common/http';\nimport { Subject, Observable, throwError } from 'rxjs';\nimport { map, first, switchMap, catchError } from 'rxjs/operators';\n\nimport { AuthService } from './auth.service';\nimport { AUTH_SERVICE } from './tokens';\n\n@Injectable()\nexport class AuthInterceptor implements HttpInterceptor {\n\n  /**\n   * Is refresh token is being executed\n   */\n  private refreshInProgress = false;\n\n  /**\n   * Notify all outstanding requests through this subject\n   */\n  private refreshSubject: Subject<boolean> = new Subject<boolean>();\n\n  constructor(private injector: Injector) {}\n\n  /**\n   * Intercept an outgoing `HttpRequest`\n   */\n  public intercept(\n    req: HttpRequest<any>,\n    delegate: HttpHandler\n  ): Observable<HttpEvent<any>> {\n    if (this.skipRequest(req)) {\n      return delegate.handle(req);\n    }\n\n    return this.processIntercept(req, delegate);\n  }\n\n  /**\n   * Process all the requests via custom interceptors.\n   */\n  private processIntercept(\n    original: HttpRequest<any>,\n    delegate: HttpHandler\n  ): Observable<HttpEvent<any>> {\n    const clone: HttpRequest<any> = original.clone();\n\n    return this.request(clone)\n      .pipe(\n        switchMap((req: HttpRequest<any>) => delegate.handle(req)),\n        catchError((res: HttpErrorResponse) => this.responseError(clone, res))\n      );\n  }\n\n  /**\n   * Request interceptor. Delays request if refresh is in progress\n   * otherwise adds token to the headers\n   */\n  private request(req: HttpRequest<any>): Observable<HttpRequest<any>> {\n    if (this.refreshInProgress) {\n      return this.delayRequest(req);\n    }\n\n    return this.addToken(req);\n  }\n\n  /**\n   * Failed request interceptor, check if it has to be processed with refresh\n   */\n  private responseError(\n    req: HttpRequest<any>,\n    res: HttpErrorResponse\n  ): Observable<HttpEvent<any>> {\n    const authService: AuthService =\n      this.injector.get<AuthService>(AUTH_SERVICE);\n    const refreshShouldHappen: boolean =\n      authService.refreshShouldHappen(res, req);\n\n    if (refreshShouldHappen && !this.refreshInProgress) {\n      this.refreshInProgress = true;\n\n      authService\n        .refreshToken()\n        .subscribe(\n          () => {\n            this.refreshInProgress = false;\n            this.refreshSubject.next(true);\n          },\n          () => {\n            this.refreshInProgress = false;\n            this.refreshSubject.next(false);\n          }\n        );\n    }\n\n    if (refreshShouldHappen && this.refreshInProgress) {\n      return this.retryRequest(req, res);\n    }\n\n    return throwError(res);\n  }\n\n  /**\n   * Add access token to headers or the request\n   */\n  private addToken(req: HttpRequest<any>): Observable<HttpRequest<any>> {\n    const authService: AuthService =\n      this.injector.get<AuthService>(AUTH_SERVICE);\n\n    return authService.getAccessToken()\n      .pipe(\n        map((token: string) => {\n          if (token) {\n            let setHeaders: { [name: string]: string | string[] };\n\n            if (typeof authService.getHeaders === 'function') {\n              setHeaders = authService.getHeaders(token);\n            } else {\n              setHeaders = { Authorization: `Bearer ${token}` };\n            }\n\n            return req.clone({ setHeaders });\n          }\n\n          return req;\n        }),\n        first()\n      );\n  }\n\n  /**\n   * Delay request, by subscribing on refresh event, once it finished, process it\n   * otherwise throw error\n   */\n  private delayRequest(req: HttpRequest<any>): Observable<HttpRequest<any>> {\n    return this.refreshSubject.pipe(\n      first(),\n      switchMap((status: boolean) =>\n        status ? this.addToken(req) : throwError(req)\n      )\n    );\n  }\n\n  /**\n   * Retry request, by subscribing on refresh event, once it finished, process it\n   * otherwise throw error\n   */\n  private retryRequest(\n    req: HttpRequest<any>,\n    res: HttpErrorResponse\n  ): Observable<HttpEvent<any>> {\n    const http: HttpClient =\n      this.injector.get<HttpClient>(HttpClient);\n\n    return this.refreshSubject.pipe(\n      first(),\n      switchMap((status: boolean) =>\n        status ? http.request(req) : throwError(res || req)\n      )\n    );\n  }\n\n  /**\n   * Checks if request must be skipped by interceptor.\n   */\n  private skipRequest(req: HttpRequest<any>) {\n    const skipRequest = this.exec('skipRequest', req);\n    const verifyRefreshToken = this.exec('verifyRefreshToken', req);\n\n    // deprecated, will be removed soon\n    const verifyTokenRequest = this.exec('verifyTokenRequest', req.url);\n\n    return skipRequest || verifyRefreshToken || verifyTokenRequest;\n  }\n\n  /**\n   * Exec optional method, will be removed in upcoming updates.\n   * Temp method until `verifyTokenRequest` will be completely replaced with skipRequest\n   */\n  private exec(method: string, ...args: any[]) {\n    const authService: AuthService =\n      this.injector.get<AuthService>(AUTH_SERVICE);\n\n    if (typeof authService[method] === 'function') {\n      return authService[method](...args);\n    }\n  }\n\n}\n","import { NgModule } from '@angular/core';\nimport { HTTP_INTERCEPTORS } from '@angular/common/http';\n\nimport { PublicGuard } from './public.guard';\nimport { ProtectedGuard } from './protected.guard';\nimport { AuthInterceptor } from './auth.interceptor';\n\n@NgModule({\n  providers: [\n    PublicGuard,\n    ProtectedGuard,\n    AuthInterceptor,\n    {\n      provide: HTTP_INTERCEPTORS,\n      useClass: AuthInterceptor,\n      multi: true,\n    }\n  ]\n})\nexport class AuthModule {\n}\n"],"names":[],"mappings":"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"}
