import { __assign } from 'tslib';
import { EventEmitter, Directive, ElementRef, Input, Output, NgModule } from '@angular/core';
import Viewer from 'viewerjs';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as ɵngcc0 from '@angular/core';
var NgxViewerDirective = /** @class */ (function () {
    function NgxViewerDirective(elementRef) {
        this.elementRef = elementRef;
        this.viewerOptions = {};
        this.viewerReady = new EventEmitter();
        this.viewerShow = new EventEmitter();
        this.viewerShown = new EventEmitter();
        this.viewerHide = new EventEmitter();
        this.viewerHidden = new EventEmitter();
        this.viewerView = new EventEmitter();
        this.viewerViewed = new EventEmitter();
        this.viewerZoom = new EventEmitter();
        this.viewerZoomed = new EventEmitter();
        this.nativeElement = this.elementRef.nativeElement;
    }
    /**
     * @return {?}
     */
    NgxViewerDirective.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        this.initViewer();
    };
    /**
     * @private
     * @return {?}
     */
    NgxViewerDirective.prototype.initViewer = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.instance) {
            this.instance.destroy();
        }
        this.instance = new Viewer(this.nativeElement, __assign({ transition: false }, this.viewerOptions));
        this.nativeElement.addEventListener('ready', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.viewerReady.emit(event); }), false);
        this.nativeElement.addEventListener('show', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.viewerShow.emit(event); }), false);
        this.nativeElement.addEventListener('shown', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.viewerShown.emit(event); }), false);
        this.nativeElement.addEventListener('hide', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.viewerHide.emit(event); }), false);
        this.nativeElement.addEventListener('hidden', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.viewerHidden.emit(event); }), false);
        this.nativeElement.addEventListener('view', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.viewerView.emit(event); }), false);
        this.nativeElement.addEventListener('viewed', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.viewerViewed.emit(event); }), false);
        this.nativeElement.addEventListener('zoom', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.viewerZoom.emit(event); }), false);
        this.nativeElement.addEventListener('zoomed', (/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.viewerZoomed.emit(event); }), false);
    };
    /**
     * @return {?}
     */
    NgxViewerDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.instance) {
            this.instance.destroy();
        }
    };
    /** @nocollapse */
    NgxViewerDirective.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    NgxViewerDirective.propDecorators = {
        viewerOptions: [{ type: Input }],
        viewerReady: [{ type: Output }],
        viewerShow: [{ type: Output }],
        viewerShown: [{ type: Output }],
        viewerHide: [{ type: Output }],
        viewerHidden: [{ type: Output }],
        viewerView: [{ type: Output }],
        viewerViewed: [{ type: Output }],
        viewerZoom: [{ type: Output }],
        viewerZoomed: [{ type: Output }]
    };
NgxViewerDirective.ɵfac = function NgxViewerDirective_Factory(t) { return new (t || NgxViewerDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
NgxViewerDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NgxViewerDirective, selectors: [["", "ngxViewer", ""]], inputs: { viewerOptions: "viewerOptions" }, outputs: { viewerReady: "viewerReady", viewerShow: "viewerShow", viewerShown: "viewerShown", viewerHide: "viewerHide", viewerHidden: "viewerHidden", viewerView: "viewerView", viewerViewed: "viewerViewed", viewerZoom: "viewerZoom", viewerZoomed: "viewerZoomed" } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxViewerDirective, [{
        type: Directive,
        args: [{
                selector: '[ngxViewer]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { viewerOptions: [{
            type: Input
        }], viewerReady: [{
            type: Output
        }], viewerShow: [{
            type: Output
        }], viewerShown: [{
            type: Output
        }], viewerHide: [{
            type: Output
        }], viewerHidden: [{
            type: Output
        }], viewerView: [{
            type: Output
        }], viewerViewed: [{
            type: Output
        }], viewerZoom: [{
            type: Output
        }], viewerZoomed: [{
            type: Output
        }] }); })();
    return NgxViewerDirective;
}());
if (false) {
    /** @type {?} */
    NgxViewerDirective.prototype.viewerOptions;
    /** @type {?} */
    NgxViewerDirective.prototype.viewerReady;
    /** @type {?} */
    NgxViewerDirective.prototype.viewerShow;
    /** @type {?} */
    NgxViewerDirective.prototype.viewerShown;
    /** @type {?} */
    NgxViewerDirective.prototype.viewerHide;
    /** @type {?} */
    NgxViewerDirective.prototype.viewerHidden;
    /** @type {?} */
    NgxViewerDirective.prototype.viewerView;
    /** @type {?} */
    NgxViewerDirective.prototype.viewerViewed;
    /** @type {?} */
    NgxViewerDirective.prototype.viewerZoom;
    /** @type {?} */
    NgxViewerDirective.prototype.viewerZoomed;
    /** @type {?} */
    NgxViewerDirective.prototype.instance;
    /**
     * @type {?}
     * @private
     */
    NgxViewerDirective.prototype.nativeElement;
    /**
     * @type {?}
     * @private
     */
    NgxViewerDirective.prototype.elementRef;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NgxViewerModule = /** @class */ (function () {
    function NgxViewerModule() {
    }
NgxViewerModule.ɵfac = function NgxViewerModule_Factory(t) { return new (t || NgxViewerModule)(); };
NgxViewerModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NgxViewerModule });
NgxViewerModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxViewerModule, [{
        type: NgModule,
        args: [{
                imports: [],
                declarations: [NgxViewerDirective],
                exports: [NgxViewerDirective]
            }]
    }], function () { return []; }, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxViewerModule, { declarations: [NgxViewerDirective], exports: [NgxViewerDirective] }); })();
    return NgxViewerModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NgxViewerDirective, NgxViewerModule };

//# sourceMappingURL=ngx-viewer.js.map